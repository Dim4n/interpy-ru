\*args и \*\*kwargs
-------------------

Я много раз замечал, что у новых Python разработчиков вызывают трудности
магические переменные \*args и \*\*kwargs. Так что же они из себя представляют?
Во-первых, позвольте сказать что вам не обязательно называть их именно
\*args и \*\*kwargs. Только ``*`` (звездочка) действительно необходима.
К примеру, их можно назвать \*var и \*\*vars. Использование \*args и \*\*kwargs
идет на уровне соглашения между разработчиками. Теперь давайте начнем рассказ
с \*args.

Использование \*args
^^^^^^^^^^^^^^^^^^^^

\*args и \*\*kwargs в основном используются в определениях функций. \*args
и \*\*kwargs позволяют передавать им произвольное число аргументов. Под
произвольным числом здесь понимается ситуация, когда вы не знаете заранее
сколько аргументов может быть передано функции пользователем, поэтому в данном
случае вам необходимо использовать эти ключевые слова. \*args используется
для передачи произвольного числа **неименнованых** аргументов функции. Вот
пример, чтобы помочь вам понять идею:

.. code:: python

    def test_var_args(f_arg, *argv):
        print("first normal arg:", f_arg)
        for arg in argv:
            print("another arg through *argv:", arg)

    test_var_args('yasoob', 'python', 'eggs', 'test')

Результат будет таким:

.. code:: python

    first normal arg: yasoob
    another arg through *argv: python
    another arg through *argv: eggs
    another arg through *argv: test

Надеюсь, пример развеял возможную путаницу. Теперь перейдем к разговору о
\*\*kwargs

Использование \*\*kwargs
^^^^^^^^^^^^^^^^^^^^^^^^

\*\*kwargs позволяет вам передавать произвольное число **именованных**
аргументов в функцию. Таким образом вам необходимо использовать \*\*kwargs там,
где вы хотите работать с **именованными** аргументами. Очередной пример:

.. code:: python

    def greet_me(**kwargs):
        for key, value in kwargs.items():
            print("{0} == {1}".format(key, value))

    >>> greet_me(name="yasoob")
    name == yasoob

Таким образом мы оперируем произвольным числом именованных аргументов в нашей
функции. Это были основы использования \*\*kwargs и можете сами отметить
насколько это может быть удобно в определенных ситуациях. Теперь давайте
рассмотрим использование \*args и \*\*kwargs для передачи в функцию списка или
словаря аргументов.

Использование \*args и \*\*kwargs для вызова функции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Рассмотрим вызов функции, используя \*args и \*\*kwargs. Пусть у нас есть вот
такая небольшая функция:

.. code:: python

    def test_args_kwargs(arg1, arg2, arg3):
        print("arg1:", arg1)
        print("arg2:", arg2)
        print("arg3:", arg3)

Мы можем использовать \*args или \*\*kwargs чтобы передать в неё аргументы.
Вот как мы это сделаем:

.. code:: python

    # Сначала с *args
    >>> args = ("two", 3, 5)
    >>> test_args_kwargs(*args)
    arg1: two
    arg2: 3
    arg3: 5

    # Теперь с **kwargs:
    >>> kwargs = {"arg3": 3, "arg2": "two", "arg1": 5}
    >>> test_args_kwargs(**kwargs)
    arg1: 5
    arg2: two
    arg3: 3

**Порядок использования \*args \*\*kwargs и формальных параметров**

Если ва хотите использовать все три метода в функции, то порядок должен быть
таким:

.. code:: python

    some_func(fargs, *args, **kwargs)

Когда их использовать?
^^^^^^^^^^^^^^^^^^^^^^

Все зависит от ваших потребностей. Наиболее часто \*args и \*\*kwargs
используются при написании декораторов (подробнее о декораторах в другой главе).
Помимо этого данная методика может использоваться для "monkey patching". Под
"monkey patching" понимается модификация кода во время выполнения программы.
Предположим у нас есть класс с методом ``get_info``, который обращается к API
и возвращает данные ответа. Для тестирования этого метода мы можем заменить
вызов API и исскуственно возвращать определенные тестовые данные. Например:

.. code:: python

    import someclass

    def get_info(self, *args):
        return "Test data"

    someclass.get_info = get_info

Уверен, вы можете придумать и другие подходящие сценарии использования.
